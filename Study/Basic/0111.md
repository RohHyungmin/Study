##01.11 :rocket:

###**운영체제**

- 운영체제는 App과 H/W 사이에서 **중재** 역할을 한다. 
(Linux, Mac os, Unix, Android, Ios, Windows...)

- 운영체제 등장 배경

```
   Computer가 많은 곳에 다양한 목적으로 사용되기 시작했다 

-> 쓸 때마다 컴퓨터 전원을 켜고 끄는 기초적인 프로그램부터 
   구동 전반에 필요한 프로그램 + 목적에 맞는 프로그램을 짜야했다(ex.수학계산).

->공통적이고 범용적인 기능을 지원하는 S/W의 필요성을 느꼈다.

->OS의 등장으로 목적에 맞는 프로그램만 짜서 쓰게 되었다. 

```

####OS의 역할

- 시스템 하드웨어 관리  

사용자 프로그램 오류, 잘못된 자원사용을 감시한다.
입/출력 장치 등의 자원에 대한 연산과 제어를 관리한다.

```
응용 프로그램 튕김, 오류 현상은 OS에서 잘못된 접근이라고 판단해 해당 프로그램을 Kill한 것이다.
```
>True/False 개념이 여기에도 접목된 것 같다.

- (가상)시스템 서비스 제공

프로그램을 쉽고 효율적으로 실행할 수 있는 환경 제공

```
사실 H/W안에는 0과 1로 이루어진 우리가 알 수 없는 형태의 자료들 뿐인데, 
이를 가상의 공간으로 바꾸어 사람이 직관적으로 인식할 수 있도록 돕는다.

```

- 자원 관리

시스템 하드웨어 및 소프트웨어 자원을 여러 프로세스에 효율적으로 할당하고 관리한다.
>한정된 자원을 어떻게 쓸 것인가? 흔히 말하는 최적화와 관련된 개념인 것 같다.

  1.  프로세스 관리

프로그램을 실행하면 memory에 명령어/data가 올라간다. 그 상태가 process다.  
**H/W에 저장되어 있는 정적상태의 data를 memory(주기억장치)에 복사해 동적상태로 만드는 것**을 말한다.  

**program** :arrow_left: :arrow_right: **process** :arrow_right_hook: **CPU**

![프로세스 도식](https://upload.wikimedia.org/wikipedia/commons/thumb/8/83/Process_states.svg/800px-Process_states.svg.png)

```

사용자나 시스템에 의해 process가 생성되면(생성) ->  CPU에 의해 process가 실행되기를 기다린다(실행 차례기다림 / 준비)
->  중앙처리장치에서 process가 실행되면(실행) ->  어떤 사건이 일어나기를 기다린다(대기) 
->  명령어가 입력되면 다시 실행 차례를 기다린다(준비) ->  다시 실행 후 종료된다.

준비상태와 실행상태는 scheduling에 따라 번갈아 나타난다.

```

- **프로세스 관리 종류**
  1.  **FCFS**(First come-First served)  
준비상태 Queue에 도착한 순서대로 CPU를 할당한다.  
앞의 프로세스가 길어지면 문제가 발생한다.  

  2.  **SJF**(Shortest Jov First)    
실행시간이 짧은 프로세스에 우선적으로 CPU를 할당한다.   
평균대기 시간이 가장 짧은 Algorithm이다.  
다만 실행시간이 긴 프로세스는 계속 순서가 밀려 언제 실행될지 가늠하기 어렵다.  

  3.  **Round Robin Scheduling**  
시분할 시스템으로 FCFS의 변형이다.  
시간을 정해놓고 시간 내에 프로세스가 완료되지 않으면 다음 프로세스에게 CPU를 할당한다.  
해당 프로세스는 Queue의 맨 끝으로 보낸다.   
할당된 시간이 클수록 FCFS와 별 차이가 없어진다.  
할당된 시간이 작을수록 문백교환과 오버헤드가 자주 발생한다.  
(잦은 큐 변경으로 실질적인 일처리 시간보다 일처리를 위한 시간이 더 길어진다.)  

  4.  **Priority Based Scheduling**  
프로세스마다 우선순위를 부여한다.  
우선순위가 동일한 경우에는 FCFS기법으로 할당한다.  
가장 낮은 우선 순위를 부여받은 프로세스의 실행이 무한 연기될 수 있다.  

  5. **Mulity Queue Scheduling**  
프로세스를 특정 그룹으로 나눌 수 있는 경우, 그룹에 따라 각자 다른 관리방법을 부여한다.  
준비단계 큐를 그룹으로 배정하고 그룹마다 FCFS, RRS 등 어울리는 큐 관리 방식을 부여하고 그룹별로 줄을 세운다.  
그룹으로 묶이면 다른 준비상태 큐로 이동이 불가능하다.  

```
싱글 코어의 경우
여러 개의 프로세스가 동시에 실행되고 있다면 
CPU를 선점하고 있는 프로세스가 끝날 때까지 기다렸다가 큐 순서에 맞게 프로세스들이 실행된다.

만약 2.7GHz CPU를 쓰고 있다면 1초에 2.7 * 2^10 * 2^10 * 2^10 속도로 연산되고 있는 것이다.

```

  **2.  주기억장치관리**

**단순관리** == memory를 mapping하고 공간을 할당하는 일

memory가 크면 미리 data를 불러놓고 process를 처리해나갈 수 있지만   
그렇지 않은 경우에는 이미 할당된 공간을 해제하고 새롭게 공간을 할당해 불러오는 것을 반복해야 하기 때문에 느리다.  

```
과도한 memory사용은 os가 해당 프로그램에게 경고 후 kill한다. 
때문에 무거운 App은 저사양 기기에서 튕김현상이 자주 일어날 수 있다.

```

**가상 메모리 관리** == 보조 기억 장치의 남는 공간을 활용해 주 기억 장치처럼 활용하는 것

중요도가 낮거나 당장 필요없는 process는 속도가 느린 보조장치에 공간을 할당해 실행하도록 한다.  
바꿔 말하면, memory가 부족할 때 App을 그냥 kill하지 않고 보조기억장치에 process를 할당하는 것이다.  

>RAM이 충분하다면, 속도가 느린 가상 memory설정은 오히려 최적의 성능에 방해될 수 있으니 끄는 것이 낫다.  

  **3. 파일관리**

- 디스크에 있는 **빈 자리를 찾고, 파일을 저장하고, 저장 위치를 알려주는 일**이다.
- OS에서 보는 파일 주소는 **가상 주소**다. 
실제 하드디스크에는 OS에서 처럼 트리형태의 폴더로 구분되어 있지 않다. 
파일 주소와 하드 디스크에 있는 주소를 OS에 있는 table로 mapping해서 찾는다.

- 파일을 저장하고 관리하는 방법은 OS마다 상이하다. 호환을 위해서 해당 OS의 table을 가져와 쓰는 방법도 있다.

**OS 별 file system**  

Unix == Unix file system  
Linux == 확장 파일 시스템, ZFS, XFS  
Mac OS == HFS, HFS+  
Windows == FAT, NTFS  

- App이 요청하는 모든 활동은 OS를 거친다.

**App** :arrow_right: :arrow_left: **OS** :arrow_right: :arrow_left: **보조기억 장치**

```
Windows 조각모음

윈도우에서는 파일 크기가 한 번에 들어갈 공간이 없으면 조각 내어 빈 공간마다 쑤셔 넣는다.
예전 하드디스크의 경우에는 파일 하나를 찾으려면 한 번의 회전이 필요했다. 이는 조각난 파일을 찾으려면
회전을 몇 번씩이나 해야 하나의 파일이 찾아지는 비효율이 발생한다. 때문에 조각 모음이 필요했다.
요즘 SSD는 random access가 가능해서 조각 모음이 필요없다.
SSD는 읽고 쓰는 횟수에 제한이 있기 때문에 많이 읽고 쓰는 조각모음을 하면 오히려 낭비다. 

```

####OS kernel

- **운영체제의 핵심, 정체성**
- 보안, 자원관리, 추상화 등의 핵심 기능
(ex. driver s/w에 의한 하드웨어 추상화 -> 하드웨어 사용 인터페이스 제공)

![](https://upload.wikimedia.org/wikipedia/commons/thumb/8/8f/Kernel_Layout.svg/380px-Kernel_Layout.svg.png)


- Mac OS 는 Unix의 커널을, Android-Fedora-Ubuntu 등은 Linux의 커널을 차용해 만들었다.
Linux도 Unix에서 파생되었기 때문에 이 모두를 **Unix-like OS**라고 한다.
Windows는 독자적인 커널을 갖고 있다.


####컴퓨터 동작 과정

- 내가 만드는 프로그램이 컴퓨터 구조 안에서 어떤 흐름을 갖고 어떤 방식으로 작동하는지
생각하면서 작업하면 문제가 생겼을 때 비교적 원활하게 대처할 수 있다.

```
음악 재생 프로그램을 실행해보자!

1. 사용자가 입력 장치를 통해 명령을 전달한다. (재생버튼 누름)
2. 입력장치가 OS를 통해 응용 프로그램에게 사용자 명령을 전달한다.(일해라. 재생 버튼 누른듯) 
3. App은 OS를 통해 HDD에 잠들어 있는 필요한 data를 요청한다.(재생하려면 노래필요함 찾아주셈)
4. HDD는 OS에게 data를 전달한다. (이거면 됨?)
5. OS는 data와 명령어를 memory에 복사한다.  (이걸로 재생하셈)
6. memory는 CPU에 명령을 복사한다. (틀어봐)
7. CPU는 명령 수행 후 memory로 결과를 복사한다. (틀었다 알지?)
8. OS는 App에게 연산이 종료되었음을 알리고 memory로부터 결과를 받아 출력장치를 통해 출력한다.(틀었대 음악 나온다 쿵짝쿵짝)

```

####Algorithm

ex) 정렬, 탐색 , 재귀 등

- 문제 해결을 위한 절차 / 방법을 말한다.
- 어떤 문제를 해결하기 위한 여러 동작들의 모음이다.
- 알고리즘에 정답은 없다. 최선만 있을 뿐.

-**Time complexity**

[시간 복잡도](https://en.wikipedia.org/wiki/Time_complexity)

알고리즘이 실행에 소요되는 시간 분석

```
최악의 경우는 O(n)
최선의 경우는 Ω(n)
평균의 경우는 θ(n) 로 표현한다.
```
보통 최악의 경우인 O(n)을 많이 쓴다.

그래프를 보면 nlongn이 연산 횟수가 완만하게 증가하는 반면, 
n제곱은 기하급수적으로 증가해 좋지않은 알고리즘이라고 할 수 있다.
자료가 늘어나도 연산 수가 증가하지 않은 n에 가까운 상태일 수록 좋은 알고리즘이다.

-**Space complexity**

메모리 사용량을 분석

```
n인 배열을 갖고 알고리즘을 실행했을 때
알고리즘 내부에서 n * n의 2차원 배열을 생성하게 된다면
알고리즘의 공간 복잡도는 n^2가 된다. 

````

빅데이터 처리시, 공간복잡도를 줄이기 위해 데이터를 나눠서 처리하고 다시 합치는 방법을 사용하기도 한다.





####Data structure

- memory의 한정된 공간을 효율적으로 활용하는 것.
- 자료를 효율적으로 이용할 수 있게 하는 방법론이다.
- data를 구조적으로 표현하는 방식이다.

```
테트리스를 예로 들면,

적절한 모양의 block(자료구조)를 돌리고 옮기는 방법(알고리즘)을 써서 게임을 클리어하는 것.

배낭 싸기를 예로 들면,

물건들의 부피를 줄이고(자료구조) 꺼내기 쉬운 순서(알고리즘)대로 차곡차곡 짐을 싸는 것.

```
> ㄴ 모양 블록으로 한 줄을 클리어하는 미션을 달성하는게 알고리즘이라면
> ㄴ 자 대신 더 효율적인 ㅁ 자 블록을 만들어 사용하는 게 자료구조다.

####Data structure 형태

- **원시구조**
동떨어져 있는 하나씩의 자료
```
[ 3 ]   [ 3.0 ]    [ a ]
```

- **선형 구조**

**1. 배열**

한 번 생성하면 크기에 변화를 줄 수 없다.
고정된 주소값을 가지기 때문에 access가 빠르다.
1,2,3차 등의 다차원 배열을 활용할 수 있다.

```
-----------------------------------------
| 0  | 1  | 2  | 3  | 4  | 5  | 6  | 7  |
-----------------------------------------

```

**2. 연결 리스트**

[연결리스트](https://ko.wikipedia.org/wiki/%EC%97%B0%EA%B2%B0_%EB%A6%AC%EC%8A%A4%ED%8A%B8)

순서대로 하나씩 물어보며 해당 값을 찾아야 해서 속도가 느리다.
주소값을 저장할 만큼의 data가 낭비된다.
값 하나가 추가되고 사라질 때마다 메모리 공간을 생성하고 해제해야 하기 때문에 프로세스가 많아진다.

배열과 비교했을 때 속도와 성능은 느리지만, 마음대로 자료를 추가하고 삭제해 크기를 조절할 수 있다. 
>최근에는 컴퓨터 성능의 향상으로 연결 리스트를 많이 쓴다.
 
**3. 스택**

[stack](https://ko.wikipedia.org/wiki/%EC%8A%A4%ED%83%9D)

ex) 웹 브라우저 뒤로가기, 스마트 폰 뒤로가기

**4. Queue**  

[큐](https://namu.wiki/w/%ED%81%90(%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0))

ex) 작업 대기열

**5. 덱**

앞/뒤에서 모두 자료가 들어오고 빠지는 구조 (doubl ended queue)

[Dequeue](https://ko.wikipedia.org/wiki/%EB%8D%B1_(%EC%9E%90%EB%A3%8C_%EA%B5%AC%EC%A1%B0))


-**비 선형구조**

**1. Tree**  

[트리](https://ko.wikipedia.org/wiki/%ED%8A%B8%EB%A6%AC_%EA%B5%AC%EC%A1%B0)

**2. Graph**  

[그래프](https://en.wikipedia.org/wiki/Graph_(abstract_data_type))

ex) 페이스북 친구 관계 표현


-------------------------

>코딩할 때는 컴퓨터는 나 없이는 아무것도 모르고 아무것도 할 줄 아는 게 없는 
>무쓸모 멍청이라고 생각하는 게 편할 것 같다.
>그리고 누구나 제약없이 볼 수 있는 표준 포맷을 중요하게 여기자. (ex. PDF, Mark down ...) :hammer:

----------------------------

